# 11.4 - SELECT

> 웹 서비스와 같이 일반적인 온라인 트랜잭션 처리 환경의 데이터베이스에서는 `INSERT`나 `UPDATE` 같은 작업은 거의 레코드 단위로 발생하므로 성능상 문제가 되는 경우는 별로 없다. 하지만 `SELECT`는 여러 개의 테이블로부터 데이터를 조합해서 빠르게 가져와야 하기 때문에 여러 개의 테이블을 어떻게 읽을 것인가에 많은 주의를 기울여야 한다. 하나의 애플리케이션에서 사용되는 쿼리 중에서도 `SELECT` 쿼리의 비율은 높다.

## 1. SELECT 절의 처리 순서

일반적인 `SELECT` 절의 처리 순서는 드라이빙 테이블(Driving Table)과 드리븐 테이블(Driven Table) 간의 `WHERE` 절 적용 및 `JOIN` 이후 `GROUP BY` -> `DISTINDCT` -> `HAVING` -> `ORDER BY` -> `LIMIT` 의 순서로 실행된다. 드라이빙 테이블(Driving Table)은 먼저 읽는 기준이 되는 테이블이고 드리븐 테이블(Driven Table)은 나중에 읽는 테이블이다.

-> SQL 쿼리의 논리적 처리 순서는 `GROUP BY` -> `HAVING` -> `DISTINDCT` 로 알고 있는데 교재의 `GROUP BY` -> `DISTINDCT` -> `HAVING` 는 아마 쿼리 최적화 과정에서 물리적 실행 순서인 것 같다.

`GROUP BY` 절이 없이 `ORDER BY` 절만 있는 상황 등에서는 드라이빙 테이블에 `WHERE` 절이 적용된 후 `ORDER BY`를 먼저 수행하고 드리븐 테이블과의 조인이 실행되는 순서로 처리되기도 한다.

위 두 실행 순서를 벗어나는 쿼리가 필요할 경우 서브쿼리로 작성된 인라인 뷰(Inline View)를 활용하면 된다.

---

## 2. WHERE 절과 GROUP BY 절, ORDER BY 절의 인덱스 사용

### 2.1 인덱스를 사용하기 위한 기본 규칙

`WHERE` 절이나 `ORDER BY` 또는 `GROUP BY`가 인덱스를 사용하려면 기본적으로 인덱스된 컬럼의 값 자체를 변환하지 않고 그대로 사용해야 한다.

`salary` 컬럼에 인덱스가 있을 때, 아래와 같이 `salary` 컬럼을 가공한 후 비교하면 이 쿼리는 인덱스를 적절하게 이용하지 못하게 된다.

```sql
SELECT * FROM salaries WHERE salary * 10 > 150000;
```

아래와 같이 간단하게 쿼리를 변경하면 되는데, MySQL 옵티마이저는 인덱스를 최적으로 이용할 수 있게 표현식을 변환지는 못한다.

```sql
SELECT * FROM salaries WHERE salary > 150000 / 10;
```

이전에 p.9처럼 문자열 컬럼을 숫자 타입 상수와 비교할 경우, 인덱스를 이용하지 못하는 것도 이 원리다.

---

## 3. WHERE 절의 비교 조건 사용 시 주의사항

### 3.1 NULL 비교

다른 DBMS와 조금 다르게 MySQL에서는 `NULL` 값이 포함된 레코드도 인덱스로 관리된다.

`to_date` 컬럼에 인덱스가 있는 경우 아래 4개의 쿼리는 전부 정상적으로 `NULL`을 판별할 수 있는 쿼리다.

```sql
SELECT * FROM titles WHERE to_date IS NULL;
SELECT * FROM titles WHERE ISNULL(to_date);
SELECT * FROM titles WHERE ISNULL(to_date) = 1;
SELECT * FROM titles WHERE ISNULL(to_date) = true;
```

다만 첫 번째와 두 번째 쿼리는 인덱스를 레인지 스캔으로 사용할 수 있지만, 세 번째와 네 번째 쿼리는 인덱스나 테이블을 풀 스캔하는 형태로 처리된다. 실행 계획을 확인해보면 첫 번째와 두 번째 쿼리는 `type`이 `ref`로, 세 번째와 네 번째 쿼리는 `type`이 `index`로 표시됐다. 가급적 `NULL` 비교는 `IS NULL` 연산자를 활용하자.

### 3.2 문자열이나 숫자 비교

문자열 컬럼이나 숫자 컬럼을 비교할 때는 반드시 그 타입에 맞는 상수값을 사용할 것을 권장한다. 비교 대상 컬럼이 문자열 컬럼이라면 문자열 리터럴을 사용하고, 숫자 타입이라면 숫자 리터럴을 이용하자.

---

## Ref

- Real MySQL 8.0 2 - p.52 ~ p.103

---
