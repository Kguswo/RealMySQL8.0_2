# 11.4.13 - 잠금을 사용하는 SELECT

## 1. FOR SHAERE & FOR UPDATE

InnoDB 테이블에 대해 레코드를 SELECT할 때 레코드에 아무런 잠금을 걸지 않는 것을 잠금 없는 읽기(Non Locking Consistent Read)라고 한다. 하지만 SELECT가 실행된 후 읽은 레코드의 칼럼 값을 애플리케이션에서 가공해서 다시 업데이트하고자 할 때 다른 트랜잭션이 그 칼럼의 값을 변경하지 못하게 해야 할 경우 레코드를 읽으면서 강제로 잠금을 걸어 둘 필요가 있는데, 이때 사용하는 옵션이 FOR SHARE와 FOR UPDATE 절이다.

FOR SHARE는 SELECT 쿼리로 읽은 레코드에 대해서 읽기 잠금(Shared Lock)을 걸고, FOR UPDATE는 SELECT 쿼리가 읽은 레코드에 대해서 쓰기 잠금(Exclusive Lock)을 건다.

아래 쿼리와 같이 간단하게 잠금을 사용하는 SELECT를 사용할 수 있다. 아래 두 가지 잠금 옵션은 모두 자동 커밋이 비활성화된 상태 또는 BEGIN 명령이나 START TRANSACTION 명령으로 트랜잭션이 시작된 상태에서만 잠금이 유지된다.

```sql
SELECT * FROM employees WHERE emp_no=10001 FOR SHARE;
SELECT * FROM employees WHERE emp_no=10001 FOR UPDATE;
```

읽기 잠금이 설정되면 다른 세션에서 해당 레코드를 변경하지는 못하지만 잠금이 걸린 레코드를 읽는 것은 가능하다. 쓰기 잠금이 설정되면 다른 트랜잭션에서는 그 레코드를 변경하는 것 뿐만 아니라 읽기(FOR SHARE 절 사용)도 수행할 수 없다.

한 가지 주의사항은 잠금 없는 읽기의 경우 이런 잠금과 무관하게 대기 없이 실행된다.

---

## 2. 잠금 테이블 선택

MySQL 8.0 버전부터는 잠금을 걸 테이블을 선택할 수 있는 OF 절을 지원한다. 아래와 같은 쿼리는 InnoDB 스토리지 엔진에서 읽은 `employees`, `dept_emp`, `departments` 테이블에서 읽은 레코드에 대해 모두 쓰기 잠금을 건다.

```sql
SELECT *
FROM employees e
    INNER JOIN dept_emp de ON de.emp_no=e.emp_no
    INNER JOIN departments d ON d.dept_no=de.dept_no
FOR UPDATE;
```

만약 `dept_emp`, `departments` 테이블은 그냥 참고용으로만 읽고, 실제 쓰기 잠금은 `employees` 테이블에만 걸고 싶다면 아래와 같이 OF 절을 활용해서 `employees` 테이블에만 쓰기 잠금을 걸 수 있다.

```sql
SELECT *
FROM employees e
    INNER JOIN dept_emp de ON de.emp_no=e.emp_no
    INNER JOIN departments d ON d.dept_no=de.dept_no
FOR UPDATE OF e;
```

---

## 3. NOWAIT & SKIP LOCKED

쓰기 잠금이 걸린 레코드에 대해 트랜잭션이 길어질 경우 다른 트랜잭션은 잠금이 해제될 때까지 장시간 대기해야할 수 있다. `innodb_lock_wait_timeout` 시스템 변수에 설정된 시간(기본 50초) 동안 기다렸다가 에러 메시지를 받는 것보다는 잠금이 걸려있으면 바로 에러를 반환하는게 좋은 상황이 있을 수 있는데 이때 사용할 수 있는 옵션이 NOWAIT이다.

SKIP LOCKED 옵션은 SELECT하려는 레코드가 다른 트랜잭션에 의해 이미 잠겨진 상태라면 에러를 반환하지 않고 잠긴 레코드는 무시하고 잠금이 걸리지 않은 레코드만 가져온다. SKIP LOCKED 옵션은 잠금이 걸린 레코드는 무시하므로 해당 SELECT 구문은 입력이 동일해도 동일한 결과를 반환하지 않을 수 있는 비확정적 쿼리(NOT-DETERMINISTIC)가 된다.

---

## 4. 쿠폰 발급 기능 만들기

NOWAIT나 SKIP LOCKED 기능은 큐와 같은 기능을 MySQL 서버에서 구현하고자 할 때 매우 유용하다. 아래와 같은 간단한 요건을 가지는 쿠폰 발급 기능을 고려해보자.

- 하나의 쿠폰은 한 사용자만 사용 가능하다.
- 쿠폰의 개수는 1000개 제한이며, 선착순으로 요청한 사용자에게 발급된다.

이와 같은 요건을 처리하기 위해 아래와 같은 테이블을 생성했다.

```sql
CREATE TABLE coupon (
    coupon_id,
    owned_user_id=0,
    coupon_code
)
```

애플리케이션에서 쿠폰을 발급할 경우 우선 아직 주인이 없는 쿠폰을 검색해서 하나를 가져온 후 주인을 해당 유저로 업데이트하고 이 과정은 쓰기 잠금내에서 이루어질 것이다.

```sql
BEGIN;

SELECT *
FROM coupon
WHERE owned_user_id=0
ORDER BY coupon_id ASC
LIMIT 1
FOR UPDATE;

...

UPDATE coupon
SET ownen_user_id=?
WHERE coupon_id=?;

COMMIT;
```

해당 기능에 대해 동시에 1000명의 사용자가 쿠폰을 요청하면 첫 요청은 아무 잠금이 없으므로 수행되지만 나머지 999개의 요청은 첫 요청과 같은 레코드를 바라보는데 이때 해당 레코드에 쓰지 잠금이 걸려있어서 첫 트랜잭션이 끝날 때까지 대기하게 되고 이후 두 번째 트랜잭션이 실행되면 다시 998개의 트랜잭션이 대기하는 과정이 반복될 것이다. 각 쿼리가 순차적으로 실행되며 매우 느려지고 일정 대기 시간을 넘어서면 타임아웃 에러를 내며 쿠폰 발급에 실패할 것이다.

MySQL 8.0 이전 버전에서는 이런 문제를 해결하기 위해 레디스나 멤캐시 같은 캐시 솔루션을 별도로 구축해서 쿠폰 발급 기능을 구현했다. 하지만 MySQL 8.0 버전부터는 UPDATE SKIP LOCKED 절을 사용하면 이미 잠금이 걸린 레코드만 스킵하면 각자의 트랜잭션을 실행할 수 있다. SKIP LOCKED 로 두 번째 트랜잭션은 잠금이 걸린 첫 레코드를 스킵하는 시간만 소요하면 두 번째 레코드에 쓰기 잠금을 획득하여 트랜잭션이 실행될 수 있고 세 번째 트랜잭션 역시 첫 번째, 두 번째 레코드를 스킵하는 시간만 소요하면 세 번째 레코드에 쓰기 잠금을 획득하여 트랜잭션이 실행될 수 있다. 이전엔느 각각의 트랜잭션이 종료되야 다음 트랜잭션이 시작했던 것과 달리 아주 약간의 스캔 시간만 소요하면 각 트랜잭션이 병렬적으로 실행될 수 있다.

---

## Ref

- Real MySQL 8.0 2 - p.139 ~ p.148

---
