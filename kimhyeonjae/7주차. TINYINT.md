### TINYINT

```sql
CREATE TABLE test (
    is_active BOOLEAN
);

SHOW CREATE TABLE test;

-- 결과:
CREATE TABLE `bool_test` (\n  `flag` tinyint(1) DEFAULT NULL\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
```

`BOOLEAN`으로 선언했지만, 실제로는 `TINYINT(1)`로 저장된다.

<br/>

### MySQL 정수 타입 체계

MySQL 문서에서는 다음과 같이 정수 타입을 정의한다.

> MySQL supports the SQL standard integer types INTEGER (or INT) and SMALLINT. As an extension to the standard, MySQL also supports the integer types TINYINT, MEDIUMINT, and BIGINT.

즉, `INTEGER`와 `SMALLINT`만 SQL 표준이고, **TINYINT, MEDIUMINT, BIGINT는 MySQL의 확장** 이다.

#### 공식 문서의 저장 크기 및 범위 표

저장 크기는 다음과 같다.

![](https://velog.velcdn.com/images/kguswo/post/43c64727-555e-45d7-891c-874495cf5ea5/image.png)


그리고 각 타입의 범위는 다음과 같다.

![](https://velog.velcdn.com/images/kguswo/post/d2ec7c76-77f8-4ff5-a1f2-6d5a4a0b4538/image.png)

<br/>

### BOOLEAN의 실체

> **BOOL, BOOLEAN**
>
> These types are synonyms for TINYINT(1). A value of zero is considered false. Nonzero values are considered true:

공식 문서가 명확하게 말하고 있다. **BOOL과 BOOLEAN은 TINYINT(1)의 동의어** 다. 

#### TRUE와 FALSE

문서에서 TRUE와 FALSE에 대해서도 설명한다.

> However, the values TRUE and FALSE are merely aliases for 1 and 0, respectively, as shown here:
>
> ```sql
> mysql> SELECT IF(0 = FALSE, 'true', 'false');
> +--------------------------------+
> | IF(0 = FALSE, 'true', 'false') |
> +--------------------------------+
> | true                           |
> +--------------------------------+
>
> mysql> SELECT IF(1 = TRUE, 'true', 'false');
> +-------------------------------+
> | IF(1 = TRUE, 'true', 'false') |
> +-------------------------------+
> | true                          |
> +-------------------------------+
>
> mysql> SELECT IF(2 = TRUE, 'true', 'false');
> +-------------------------------+
> | IF(2 = TRUE, 'true', 'false') |
> +-------------------------------+
> | false                         |
> +-------------------------------+
>
> mysql> SELECT IF(2 = FALSE, 'true', 'false');
> +--------------------------------+
> | IF(2 = FALSE, 'true', 'false') |
> +--------------------------------+
> | false                          |
> +--------------------------------+
> ```
>
> The last two statements display the results shown because 2 is equal to neither 1 nor 0.

즉 **TRUE는 1의 별칭이고, FALSE는 0의 별칭** 이다. 따라서 2는 TRUE(1)도 아니고 FALSE(0)도 아니다.

> BOOLEAN 컬럼을 조건으로 사용할 때 `WHERE flag = TRUE`는 flag가 정확히 1인 경우만 참이 된다. 0이 아닌 모든 값을 참으로 처리하려면 `WHERE flag` 또는 `WHERE flag != 0`을 사용해야 한다.

<br/>

### Display Width (1)의 의미

많은 개발자가 `TINYINT(1)`의 `(1)`을 "1바이트" 또는 "1비트"로 오해한다. 

Display Width란

> MySQL supports an extension for optionally specifying the display width of integer data types in parentheses following the base keyword for the type. For example, INT(4) specifies an INT with a display width of four digits.
>
> **The display width does not constrain the range of values that can be stored in the column.** Nor does it prevent values wider than the column display width from being displayed correctly.

즉, Display Width는 **저장 공간과 전혀 관계가 없다.** 단지 표시 너비를 의미할 뿐이다.

<br/>

더 구체적인 내용으로는

> Display width specification for integer data types was deprecated in MySQL 8.0.17, and now statements that include data type definitions in their output no longer show the display width for integer types, **with these exceptions:**
>
> - **The type is TINYINT(1).** MySQL Connectors make the assumption that TINYINT(1) columns originated as BOOLEAN columns; this exception enables them to continue to make that assumption.
> - The type includes the ZEROFILL attribute.

**TINYINT(1)만 예외적으로 Display Width가 유지** 되는 이유는, MySQL Connector들이 TINYINT(1)을 BOOLEAN 컬럼으로 인식하기 때문이다.

> MySQL 8.0.17 이후 버전에서는 TINYINT(1)을 제외한 정수 타입의 Display Width 지정이 deprecated 되었다.

<br/>

### BIT 타입은 대안이 될 수 있는가?


> The BIT data type is used to store bit values. A type of BIT(M) enables storage of M-bit values. M can range from 1 to 64.

![](https://velog.velcdn.com/images/kguswo/post/59d14c74-da7b-409c-8481-7b6a35d7ccb4/image.png)

**BIT(M)의 저장 크기는 `(M+7)/8` 바이트** 다. 즉:

| 선언    | 계산                 | 실제 저장 크기 |
| ------- | -------------------- | -------------- |
| BIT(1)  | (1+7)/8 = 1          | 1바이트        |
| BIT(8)  | (8+7)/8 = 1.875 → 1  | 1바이트        |
| BIT(9)  | (9+7)/8 = 2          | 2바이트        |
| BIT(64) | (64+7)/8 = 8.875 → 8 | 8바이트        |

결론적으로 **BIT(1)과 TINYINT는 동일하게 1바이트를 사용** 한다.

<br/>

### JDBC에서의 타입 매핑 문제

Java 애플리케이션에서 MySQL을 사용할 때, TINYINT(1)과 BOOLEAN의 매핑은 중요한 문제다.

#### MySQL Connector/J 공식 문서

[MySQL Connector/J Developer Guide - 6.3.8 Result Sets](https://dev.mysql.com/doc/connector-j/en/connector-j-connp-props-result-sets.html) 문서에서 두 가지 중요한 설정을 확인할 수 있다.

- **tinyInt1isBit**

이 설정은 MySQL의 TINYINT(1) 타입을 자바의 BIT (결국 Boolean) 타입으로 취급할지 결정한다.

> Since the MySQL server silently converts BIT to TINYINT(1) when creating tables, should the driver treat the datatype TINYINT(1) as the BIT type?
>
> | | |
> |---|---|
> | **Default Value** | true |
> | **Since Version** | 3.0.16 |

- **transformedBitIsBoolean**

이 설정은 위의 과정에서 타입을 변환할 때, 그 이름을 무엇으로 부를지에 대한 세부 설정이다.

> If the driver converts TINYINT(1) to a different type, should it use BOOLEAN instead of BIT?
>
> | | |
> |---|---|
> | **Default Value** | false |
> | **Since Version** | 3.1.9 |

기본 설정에서 TINYINT(1)은 BIT로 변환된다. `transformedBitIsBoolean=true`로 설정하면 `java.lang.Boolean`으로 매핑된다.


#### JDBC 연결 문자열 설정

```yml
# TINYINT(1)을 Boolean으로 매핑
spring.datasource.url=jdbc:mysql://localhost:3306/mydb?tinyInt1isBit=true&transformedBitIsBoolean=true
```

<br/>

### 데이터 무결성 보장하기

BOOLEAN 용도로 TINYINT(1)을 사용할 때, 0과 1 외의 값이 저장되는 것을 방지하려면 CHECK 제약조건을 사용할 수 있다.

#### CHECK 제약조건 (MySQL 8.0.16+)

```sql
CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    is_active TINYINT(1) NOT NULL DEFAULT 1,
    CONSTRAINT chk_is_active CHECK (is_active IN (0, 1))
);

INSERT INTO users (is_active) VALUES (1);
INSERT INTO users (is_active) VALUES (0);
INSERT INTO users (is_active) VALUES (2);  -- 실패
```

에러 메시지:
```sql
ERROR 3819 (HY000) at line 9: Check constraint 'chk_is_active' is violated.
```

> MySQL 8.0.16 이전 버전에서는 CHECK 제약조건이 파싱되지만 무시된다. 8.0.16 이상에서만 실제로 동작한다.

<br/>

---

### References

- [MySQL 8.0 Reference Manual - 13.1.1 Numeric Data Type Syntax](https://dev.mysql.com/doc/refman/8.0/en/numeric-type-syntax.html)
- [MySQL 8.0 Reference Manual - 13.1.2 Integer Types](https://dev.mysql.com/doc/refman/8.0/en/integer-types.html)
- [MySQL 8.0 Reference Manual - 13.1.6 Numeric Type Attributes](https://dev.mysql.com/doc/refman/8.0/en/numeric-type-attributes.html)
- [MySQL 8.0 Reference Manual - 13.7 Data Type Storage Requirements](https://dev.mysql.com/doc/refman/8.0/en/storage-requirements.html)
- [MySQL Connector/J Developer Guide - 6.3.8 Result Sets](https://dev.mysql.com/doc/connector-j/en/connector-j-connp-props-result-sets.html)
- [MySQL 8.0.19 Release Notes](https://dev.mysql.com/doc/relnotes/mysql/8.0/en/news-8-0-19.html)